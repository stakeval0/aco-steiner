
#######################################################################
#
# functions.R - R implementation of popular test functions for both
#	              continuous and mixed-variable optimization problems.
#
# Copyright (c) 2006 by Krzysztof Socha (ksocha@ulb.ac.be)
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by 
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#

#######################################################################
#
# Each test function 'foo' is defined as a set of objects described
# below. Each function is considered to be a maximization problem (any
# optimization function may be easily translated to such problem). 
#
# First object (foo.d) is a list that is the domain definition - for each
# variable the variable type must be defined as one of the following:
#   u - unordered discrete variable
#   o - ordered discrete variable
#   x - continuous variable
# Following the variable type, the domain must be defined for each 
# variable. For "u" and "o" variables, all possible values must be 
# specified. For "x" variable the lower and upper bound must be given.
# 
# NOTE: All the discrete variables MUST be defined before any continuous
#       variables!
# 
# Second object (foo.tf) is a function performing the mapping from 
# the values generated by the algorithm to the values from the defined
# earlier domain. Usually, for continuous and ordered variables there 
# is a direct mapping, and for unordered - categorical - variables 
# there is a mapping from the index number to the actual value.
# There may be some additional translations or repair mechanisms 
# implemented as well - an option left for the designer. See example
# test functions for details how this may be done.
#
# Third object (foo.f) is the actual objective function. The first 
# function that is called must be the foo.tf function in order to map 
# the values generated by the algorithm to the actual values from the 
# respective variables' domains. Only then the actual objective function
# value may be calculated and returned.
#
# Finally the last object is a collection of all the previous objects
# of the form:
#		foo <- c(f=foo.f,d=list(foo.d),tf=foo.tf,opt=<optimal value>)
# where the <optimal value> is the known a priori optimal value of the 
# objective function. If the optimal value is not known, it is sufficient
# to specify a high enough value (reminder: all functions are considered
# to be maximization problems).
#
# Below, a template of a function is given. Additional insight into 
# designing test functions may be obtained through the analysis of the 
# (numerous) examples provided.
#

#######################################################################
# Test Function Template (FOO)
#
# foo.d <- list(
#		list("<variable type>",<domain>),
#		.
#		.
#		.
#		list("<variable type>",<domain>))
#
#	foo.tf <- function(u,o,x) {
#		<mapping: X <- f(u,o,x)>
#		return(X)
# }
#
# foo.f <- function(u,o,x) {
#		X <- foo.tf(u,o,x)
#		<function body: y <- f(X)>
#		return(y)
# }
#
# foo <- c(f=foo.f,d=list(foo.d),tf=foo.tf,opt=<optimal value>)


# load required utility functions
source("utilities.R")


#######################################################################
#
# Continuous Test Functions
# 
#######################################################################

#######################################################################
# Easom (ES)
#
# Dim:    : 2
# Domain  : (-100,100)^2
# Optimum : f=1; (pi,pi)

es.d <- list(
	list("x",c(-100,100)),
	list("x",c(-100,100)))

es.tf <- function(u,o,x) {
	X <- x
	return(X)
}

es.f <- function(u,o,x) {
	x <- es.tf(u,o,x)
  return (cos(x[,1])*cos(x[,2])*exp(-((x[,1]-pi)^2+(x[,2]-pi)^2)))
}

es <- c(f=es.f,d=list(es.d),tf=es.tf,opt=1)


#######################################################################
# Branin RCOS (RC)
#
# Dim:    : 2
# Domain  : (-5,15)^2 
# Optimum : ~ -0.397887

rc.d <- list(
	list("x",c(-5,15)),
	list("x",c(-5,15)))

rc.tf <- function(u,o,x) {
	X <- x
	return(X)
}

rc.f <- function(u,o,x) {
	x <- rc.tf(u,o,x)
  return(-((x[,2]-(5/(4*pi^2))*x[,1]^2+(5/pi)*
    x[,1]-6)^2+10*(1-(1/(8*pi)))*cos(x[,1])+10))
}

rc <- c(f=rc.f,d=list(rc.d),tf=rc.tf,opt=-0.397887)


#######################################################################
# B2
#
# Dim:    : 2
# Domain  : [-100,100]^2
# Optimum : 0 @ (0,0)

b2.d <- list(
	list("x",c(-100,100)),
	list("x",c(-100,100)))

b2.tf <- function(u,o,x) {
	X <- x
	return(X)
}

b2.f <- function(u,o,x) {
	x <- b2.tf(u,o,x)
  return(-(x[,1]^2+2*x[,2]^2-0.3*cos(3*pi*
    x[,1])-0.4*cos(4*pi*x[,2])+0.7))
}

b2 <- c(f=b2.f,d=list(b2.d),tf=b2.tf,opt=0)


#######################################################################
# Goldstein and Price (GP)
#
# Dim:    : 2
# Domain  : [-2,2]^2
# Optimum : -3 @ (0,-1)

gp.d <- list(
	list("x",c(-2,2)),
	list("x",c(-2,2)))

gp.tf <- function(u,o,x) {
	X <- x
	return(X)
}

gp.f <- function(u,o,x) {
	x <- gp.tf(u,o,x)
  return(-(1+(x[,1]+x[,2]+1)^2*(19-14*x[,1]+13*x[,1]^2-14*x[,2]+6*
    x[,1]*x[,2]+3*x[,2]^2))*(30+(2*x[,1]-3*x[,2])^2*(18-32*x[,1]+12*
    x[,1]^2+48*x[,2]-36*x[,1]*x[,2]+27*x[,2]^2)))
}

gp <- c(f=gp.f,d=list(gp.d),tf=gp.tf,opt=-3)


#######################################################################
# Martin & Gaddy (MG)
#
# Dim:    : 2
# Domain  : [-20,20]^2 
# Optimum : 0 @ (5,5)

mg.d <- list(
	list("x",c(-20,20)),
	list("x",c(-20,20)))

mg.tf <- function(u,o,x) {
	X <- x
	return(X)
}

mg.f <- function(u,o,x) {
	x <- mg.tf(u,o,x)
  return(-((x[,1]-x[,2])^2+((x[,1]+x[,2]-10)/3)^2))
}

mg <- c(f=mg.f,d=list(mg.d),tf=mg.tf,opt=0)


#######################################################################
# De Jong (DJ)
#
# Dim:    : 3
# Domain  : [-5.12,5.12]^3
# Optimum : 0 @ (0,0,0)

dj.d <- list(
	list("x",c(-5.12,5.12)),
	list("x",c(-5.12,5.12)),
	list("x",c(-5.12,5.12)))

dj.tf <- function(u,o,x) {
	X <- x
	return(X)
}

dj.f <- function(u,o,x) {
	x <- dj.tf(u,o,x)
  return(-(x[,1]^2+x[,2]^2+x[,3]^2))
}

dj <- c(f=dj.f,d=list(dj.d),tf=dj.tf,opt=0)


#######################################################################
# Sphere Model (SM)
#
# Dim:    : n
# Domain  : [-5.12,5.12]^n or [-100,100]^n
# Optimum : 0@(0,0)
# Comment : Now defined for n=6, but may be easily modified.

sm.d <- list(
	list("x",c(-5.12,5.12)),
	list("x",c(-5.12,5.12)),
	list("x",c(-5.12,5.12)),
	list("x",c(-5.12,5.12)),
	list("x",c(-5.12,5.12)),
	list("x",c(-5.12,5.12)))

sm.tf <- function(u,o,x) {
	X <- x
	return(X)
}

sm.f <- function(u,o,x) {
	x <- sm.tf(u,o,x)
  Y <- rep(0,dim(x)[1])
  for (j in 1:(dim(x)[2])) {
    Y <- Y + (x[,j])^2
  }
  return(-Y)
}

sm <- c(f=sm.f,d=list(sm.d),tf=sm.tf,opt=0)


#######################################################################
# Hartmann (H3,4)
#
# Dim:    : 3
# Domain  : [0,1]^3
# Optimum : 3.86278

h34.d <- list(
	list("x",c(0,1)),
	list("x",c(0,1)),
	list("x",c(0,1)))

h34.tf <- function(u,o,x) {
	X <- x
	return(X)
}

h34.f <- function(u,o,x) {
	x <- h34.tf(u,o,x)
  c <- c(1.0, 1.2, 3.0, 3.2)
  a <- c(c(3.0, 0.1, 3.0, 0.1), c(10, 10, 10, 10), c(30, 35, 30, 35))
  dim(a) <- c(4,3)
  p <- c(
    c(0.3689, 0.4699, 0.1091, 0.0381), 
    c(0.1170, 0.4387, 0.8732, 0.5743), 
    c(0.2673, 0.7470, 0.5547, 0.8828))
  dim(p) <- c(4,3)
  Y <- rep(0,dim(x)[1])
  for (i in 1:4) {
    y <- rep(0,dim(x)[1])
    for (j in 1:3) {
        y <- y + a[i,j]*(x[,j]-p[i,j])^2
    }
    Y <- Y - c[i]*exp(-y)
  }
  return (-Y)
}

h34 <- c(f=h34.f,d=list(h34.d),tf=h34.tf,opt=3.86278)


#######################################################################
# Hartmann (H6,4)
#
# Dim:    : 6
# Domain  : [0,1]^6
# Optimum : 3.334236

h64.d <- list(
	list("x",c(0,1)),
	list("x",c(0,1)),
	list("x",c(0,1)),
	list("x",c(0,1)),
	list("x",c(0,1)),
	list("x",c(0,1)))

h64.tf <- function(u,o,x) {
	X <- x
	return(X)
}

h64.f <- function(u,o,x) {
	x <- h64.tf(u,o,x)
  c <- c(1.0, 1.2, 3.0, 3.2)
  a <- c(
    c(10, 3, 17, 3.5, 1.7, 8), 
    c(0.05, 10, 17, 0.1, 8, 14), 
    c(3, 3.5, 1.7, 10, 17, 8), 
    c(17, 8, 0.05, 10, 0.1, 14))
  dim(a) <- c(4,6)
  p <- c(
    c(0.1312, 0.1696, 0.5569, 0.0124, 0.8283, 0.5886), 
    c(0.2329, 0.4135, 0.8307, 0.3736, 0.1004, 0.9991), 
    c(0.2348, 0.1451, 0.3522, 0.2883, 0.3047, 0.6650), 
    c(0.4047, 0.8828, 0.8732, 0.5743, 0.1091, 0.0381))
  dim(p) <- c(4,6)
  Y <- rep(0,dim(x)[1])
  for (i in 1:4) {
    y <- rep(0,dim(x)[1])
    for (j in 1:6) {
        y <- y + a[i,j]*(x[,j]-p[i,j])^2
    }
    Y <- Y - c[i]*exp(-y)
  }
  return (-Y)
}

h64 <- c(f=h64.f,d=list(h64.d),tf=h64.tf,opt=3.334236)


#######################################################################
# Shekel (S4,p)
#
# Dim:    : 4
# Domain  : [0,10]^4
# Optimum : 10.1532 : p=5, 10.40294 : p=7, 10.53641 : p=10

s4p.d <- list(
	list("x",c(0,10)),
	list("x",c(0,10)),
	list("x",c(0,10)),
	list("x",c(0,10)))

s4p.tf <- function(u,o,x) {
	X <- x
	return(X)
}

s4p.f <- function(u,o,x,p) {
	x <- s4p.tf(u,o,x)
  ai <- c(
    c(4, 4, 4, 4), c(1, 1, 1, 1), c(8, 8, 8, 8), 
    c(6, 6, 6, 6), c(3, 7, 3, 7), c(2, 9, 2, 9), 
    c(5, 5, 3, 3), c(8, 1, 8, 1), c(6, 2, 6, 2), c(7, 3.6, 7, 3.6))
  dim(ai) <- c(4,10)
  ai <- t(ai)
  ci <- c(0.1, 0.2, 0.2, 0.4, 0.4, 0.6, 0.3, 0.7, 0.5, 0.5)
  Y <- rep(0,dim(x)[1])
  for (i in 1:p) {
    aii <-  t(matrix(ai[i,],4,dim(x)[1]))
    Y <- Y - 1 / (diag((x - aii) %*% t(x - aii)) + ci[i])
  }
  return(-Y)
}

s45.f <- function(u,o,x,p=5) {
  s4p.f(NULL,NULL,x,p)
}
s45 <- c(f=s45.f,d=list(s4p.d),tf=s4p.tf,opt=10.1532)

s47.f <- function(u,o,x,p=7) {
  s4p.f(NULL,NULL,x,p)
}
s47 <- c(f=s47.f,d=list(s4p.d),tf=s4p.tf,opt=10.40294)

s410.f <- function(u,o,x,p=10) {
  s4p.f(NULL,NULL,x,p)
}
s410 <- c(f=s410.f,d=list(s4p.d),tf=s4p.tf,opt=10.53641)


#######################################################################
# Rosenbrock (Rn)
#
# Dim:    : n
# Domain  : [-5,10]^n or [-5,5]^n
# Optimum : 0 @ (1,..,1)
# Comment : Now defined for n=2, but may be easily modified.

rn.d <- list(
	list("x",c(-5,10)),
	list("x",c(-5,10)))

rn.tf <- function(u,o,x) {
	X <- x
	return(X)
}

rn.f <- function(u,o,x) {
	x <- rn.tf(u,o,x)
  Y <- rep(0,dim(x)[1])
  for (j in 1:(dim(x)[2]-1)) {
    Y <- Y + 100*(x[,j]^2-x[,j+1])^2+(x[,j]-1)^2
  }
  return(-Y)
}

rn <- c(f=rn.f,d=list(rn.d),tf=rn.tf,opt=0)


#######################################################################
# Zakharov (Zn)
#
# Dim:    : n
# Domain  : [-5,10]^n
# Optimum : 0 @ (0,...,0)
# Comment : Now defined for n=2, but may be easily modified.

zn.d <- list(
	list("x",c(-5,10)),
	list("x",c(-5,10)))

zn.tf <- function(u,o,x) {
	X <- x
	return(X)
}

zn.f <- function(u,o,x) {
	x <- zn.tf(u,o,x)
  Y.1 <- rep(0,dim(x)[1])
  for (j in 1:dim(x)[2]) {
    Y.1 <- Y.1 + x[,j]^2
  }
  Y.2 <- rep(0,dim(x)[1])
  for (j in 1:dim(x)[2]) {
    Y.2 <- Y.2 + 0.5*j*x[,j]^2
  }
  Y.3 <- rep(0,dim(x)[1])
  for (j in 1:dim(x)[2]) {
    Y.3 <- Y.3 + 0.5*j*x[,j]^2
  }
  return(-Y.1-Y.2^2-Y.3^4)
}

zn <- c(f=zn.f,d=list(zn.d),tf=zn.tf,opt=0)


#######################################################################
# Griewank (Gr_n)
#
# Dim:    : n
# Domain  : [-5.12,5.12]^n
# Optimum : 0 @ (0,...,0)
# Comment : Now defined for n=10, but may be easily modified.

gr.d <- list(
	list("x",c(-5.12,5.12)),
	list("x",c(-5.12,5.12)),
	list("x",c(-5.12,5.12)),
	list("x",c(-5.12,5.12)),
	list("x",c(-5.12,5.12)),
	list("x",c(-5.12,5.12)),
	list("x",c(-5.12,5.12)),
	list("x",c(-5.12,5.12)),
	list("x",c(-5.12,5.12)),
	list("x",c(-5.12,5.12)))

gr.tf <- function(u,o,x) {
	X <- x
	return(X)
}

gr.f <- function(u,o,x) {
	x <- gr.tf(u,o,x)
  Y1 <- rep(0,dim(x)[1])
  Y2 <- rep(1,dim(x)[1])
  for (j in 1:(dim(x)[2])) {
    Y1 <- Y1 + (1/4000)*x[,j]^2
    Y2 <- Y2 * cos(x[,j]/sqrt(j))
  }
  Y <- Y1 - Y2 + 1
  return(-Y)
}

gr <- c(f=gr.f,d=list(gr.d),tf=gr.tf,opt=0)


#######################################################################
# Plane (pl)
#
# Dim:    : n
# Domain  : [0.5,1.5]^n
# Optimum : 0
# Comment : Now defined for n=10, but may be easily modified.

pl.d <- list(
	list("x",c(0.5,1.5)),
	list("x",c(0.5,1.5)),
	list("x",c(0.5,1.5)),
	list("x",c(0.5,1.5)),
	list("x",c(0.5,1.5)),
	list("x",c(0.5,1.5)),
	list("x",c(0.5,1.5)),
	list("x",c(0.5,1.5)),
	list("x",c(0.5,1.5)),
	list("x",c(0.5,1.5)))

pl.tf <- function(u,o,x) {
	X <- x
	return(X)
}

pl.f <- function(u,o,x) {
	x <- pl.tf(u,o,x)
  return(x[,1]-10^10+1)
}

pl <- c(f=pl.f,d=list(pl.d),tf=pl.tf,opt=0)


#######################################################################
# Diagonal Plane (dp)
#
# Dim:    : n
# Domain  : [0.5,1.5]^n
# Optimum : 0
# Comment : Now defined for n=10, but may be easily modified.

dp.d <- list(
	list("x",c(0.5,1.5)),
	list("x",c(0.5,1.5)),
	list("x",c(0.5,1.5)),
	list("x",c(0.5,1.5)),
	list("x",c(0.5,1.5)),
	list("x",c(0.5,1.5)),
	list("x",c(0.5,1.5)),
	list("x",c(0.5,1.5)),
	list("x",c(0.5,1.5)),
	list("x",c(0.5,1.5)))

dp.tf <- function(u,o,x) {
	X <- x
	return(X)
}

dp.f <- function(u,o,x) {
	x <- dp.tf(u,o,x)
  Y <- rep(0,dim(x)[1])
  for (j in 1:(dim(x)[2])) {
    Y <- Y + (x[,j])
  }
  return((Y-10^10+1)/dim(x)[2])
}

dp <- c(f=dp.f,d=list(dp.d),tf=dp.tf,opt=0)


#######################################################################
# Ellipsoid (EL)
#
# Dim:    : n
# Domain  : [-3,7]^n
# Optimum : 0 @ (0,..,0)
# Comment : Now defined for n=10, but may be easily modified.

el.d <- list(
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)))

el.tf <- function(u,o,x) {
	X <- x
	return(X)
}

el.f <- function(u,o,x) {
	x <- el.tf(u,o,x)
  Y <- rep(0,dim(x)[1])
  for (j in 1:(dim(x)[2])) {
    Y <- Y + (100^((j-1)/(dim(x)[2]-1))*x[,j])^2
  }
  return(-Y)
}

el <- c(f=el.f,d=list(el.d),tf=el.tf,opt=0)


#######################################################################
# Cigar (CG)
#
# Dim:    : n
# Domain  : [-3,7]^n
# Optimum : 0 @ (0,..,0)
# Comment : Now defined for n=10, but may be easily modified.

cg.d <- list(
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)))

cg.tf <- function(u,o,x) {
	X <- x
	return(X)
}

cg.f <- function(u,o,x) {
	x <- cg.tf(u,o,x)
  Y <- x[,1]^2
  for (j in 2:(dim(x)[2])) {
    Y <- Y + 10^4*x[,j]^2
  }
  return(-Y)
}

cg <- c(f=cg.f,d=list(cg.d),tf=cg.tf,opt=0)


#######################################################################
# Tablet (TB)
#
# Dim:    : n
# Domain  : [-3,7]^n
# Optimum : 0 @ (0,..,0)
# Comment : Now defined for n=10, but may be easily modified.

tb.d <- list(
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)))

tb.tf <- function(u,o,x) {
	X <- x
	return(X)
}

tb.f <- function(u,o,x) {
	x <- tb.tf(u,o,x)
  Y <- 10^4*x[,1]^2
  for (j in 2:(dim(x)[2])) {
    Y <- Y + x[,j]^2
  }
  return(-Y)
}

tb <- c(f=tb.f,d=list(tb.d),tf=tb.tf,opt=0)


#######################################################################
# Ellipsoid (randomly rotated) (rEL)
#
# Dim:    : n
# Domain  : [-3,7]^n
# Optimum : 0 @ (0,..,0)
# Comment : Now defined for n=10, but may be easily modified.
#           This test function requires rel.R global matrix to be
#						defined (preferably using gen.R utility function).

rel.d <- list(
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)))

rel.tf <- function(u,o,x) {
	X <- x
	return(X)
}

rel.f <- function(u,o,x) {
	x <- rel.tf(u,o,x)
  rx <- t(rel.R %*% t(x))
  Y <- rep(0,dim(rx)[1])
  for (j in 1:(dim(rx)[2])) {
    Y <- Y + (100^((j-1)/(dim(rx)[2]-1))*rx[,j])^2
  }
  return(-Y)
}

rel <- c(f=rel.f,d=list(rel.d),tf=rel.tf,opt=0)


#######################################################################
# Cigar (randomly rotated) (rCG)
#
# Dim:    : n
# Domain  : [-3,7]^n
# Optimum : 0 @ (0,..,0)
# Comment : Now defined for n=10, but may be easily modified.
#           This test function requires rcg.R global matrix to be
#						defined (preferably using gen.R utility function).

rcg.d <- list(
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)))

rcg.tf <- function(u,o,x) {
	X <- x
	return(X)
}

rcg.f <- function(u,o,x) {
	x <- rcg.tf(u,o,x)
  rx <- t(rcg.R %*% t(x))
  Y <- rx[,1]^2
  for (j in 2:(dim(rx)[2])) {
    Y <- Y + 10^4*rx[,j]^2
  }
  return(-Y)
}

rcg <- c(f=rcg.f,d=list(rcg.d),tf=rcg.tf,opt=0)


#######################################################################
# Tablet (randomly rotated) (rTB)
#
# Dim:    : n
# Domain  : [-3,7]
# Optimum : 0 @ (0,..,0)
# Comment : Now defined for n=10, but may be easily modified.
#           This test function requires rtb.R global matrix to be
#						defined (preferably using gen.R utility function).

rtb.d <- list(
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)),
	list("x",c(-3,7)))

rtb.tf <- function(u,o,x) {
	X <- x
	return(X)
}

rtb.f <- function(u,o,x) {
	x <- rtb.tf(u,o,x)
  rx <- t(rtb.R %*% t(x))
  Y <- 10^4*rx[,1]^2
  for (j in 2:(dim(rx)[2])) {
    Y <- Y + rx[,j]^2
  }
  return(-Y)
}

rtb <- c(f=rtb.f,d=list(rtb.d),tf=rtb.tf,opt=0)


#######################################################################
#
# Mixed Variable Test Functions
#
#######################################################################


#######################################################################
# Discretized Ellipsoid (randomly rotated) (uirEL) (random ordering)
# Discrete variables are assumed to be ordered
#
# Dim:		: n
# Domain  : [-3,7]x{-3,-2,-1,0,1,2,3,4,5,6,7}x...	 
#           (every other dimention's domain is integer)
# Optimum : 0 @ (0,...,0)
# Comment : Now defined for n=2, but may be easily modified.


uirel.d <- list(
	list("o",sample(seq.a(-3,7,length.out=resolution),resolution)),
	list("x",c(-3,7)))

uirel.tf <- function(u,o,x) {
	o <- round(o)
	o[o<1] <- 1
	o[o>length(uirel.d[[1]][[2]])] <- length(uirel.d[[1]][[2]])
	X <- cbind(x,uirel.d[[1]][[2]][o])
	return(X)
}

uirel.f <- function(u,o,x) {
	X <- uirel.tf(u,o,x)
	X <- t(uirel.R %*% t(X))
	Y <- rep(0,dim(X)[1])
	for (j in 1:(dim(X)[2])) {
		Y <- Y + (100^((j-1)/(dim(X)[2]-1))*X[,j])^2
	}
	return(-Y)
}

uirel <- c(f=uirel.f,d=list(uirel.d),tf=uirel.tf,type=1,opt=0)


#######################################################################
# Discretized Ellipsoid (randomly rotated) (uuirEL)	(random ordering)
# Discrete variables are assumed to be unordered - categorical ones
#
# Dim:		: n
# Domain  : [-3,7]x{-3,-2,-1,0,1,2,3,4,5,6,7}x...	 
#           (every other dimention's domain is integer)
# Optimum : 0 @ (0,..,0)
# Comment : Now defined for n=2, but may be easily modified.

# categorical and integer variables MUST be defined first
uuirel.d <- list(
	list("u",sample(seq.a(-3,7,length.out=resolution),resolution)),
	list("x",c(-3,7)))

uuirel.tf <- function(u,o,x) {
	X <- cbind(x,uuirel.d[[1]][[2]][u])
	return(X)
}

uuirel.f <- function(u,o,x) {
	X <- uuirel.tf(u,o,x)
	X <- t(uuirel.R %*% t(X))
	Y <- rep(0,dim(X)[1])
	for (j in 1:(dim(X)[2])) {
		Y <- Y + (100^((j-1)/(dim(X)[2]-1))*X[,j])^2
	}
	return(-Y)
}

uuirel <- c(f=uuirel.f,d=list(uuirel.d),tf=uuirel.tf,type=1,opt=0)


#######################################################################
# Coil Spring Design (CSD) with soft constraints
# This version uses ordered discrete variables
#
# Dim:		: 3
# Domain  : {	0.0090 0.0095 0.0104 0.0118 0.0128 0.0132
#							0.0140 0.0150 0.0162 0.0173 0.0180 0.0200
#							0.0230 0.0250 0.0280 0.0320 0.0350 0.0410
#							0.0470 0.0540 0.0630 0.0720 0.0800 0.0920
#							0.1050 0.1200 0.1350 0.1480 0.1620 0.1770
#							0.1920 0.2070 0.2250 0.2440 0.2630 0.2830
#							0.3070 0.3310 0.3620 0.3940 0.4375 0.5000	} x {1,...,70} x (0.6,3)
# Optimum : f=2.658559 (best known)

csd.d <- list(
	list("o",seq(1,70)),		# x1 - number of coils
	list("o",c(	0.0090,0.0095,0.0104,0.0118,0.0128,0.0132,  # x3 - wire diameter
							0.0140,0.0150,0.0162,0.0173,0.0180,0.0200,
							0.0230,0.0250,0.0280,0.0320,0.0350,0.0410,
							0.0470,0.0540,0.0630,0.0720,0.0800,0.0920,
							0.1050,0.1200,0.1350,0.1480,0.1620,0.1770,
							0.1920,0.2070,0.2250,0.2440,0.2630,0.2830,
							0.3070,0.3310,0.3620,0.3940,0.4375,0.5000)),
	list("x",c(0.6,3))) # x2 - spring diameter

csd.tf <- function(u,o,x) {
	dim(o) <- c(length(o)/2,2)
	o <- round(o)
	o[o<1] <- 1
	o[,1][o[,1]>length(csd.d[[1]][[2]])] <- length(csd.d[[1]][[2]])
	o[,2][o[,2]>length(csd.d[[2]][[2]])] <- length(csd.d[[2]][[2]])
	X <- cbind(csd.d[[1]][[2]][o[,1]],x,csd.d[[2]][[2]][o[,2]])
	return(X)
}

csd.f <- function(u,o,x) {
	X <- csd.tf(u,o,x)	
	x.1 <- X[,1]
	x.2 <- X[,2]
	x.3 <- X[,3]
	Y <- pi^2*x.2*x.3^2*(x.1+2)/4
	# constraints handling
	G <- 11.5*10^6
	F.p <- 300
	F.max <- 1000
	S <- 189000
	sigma.pm <- 6
	sigma.w <- 1.25
	l.max <- 14
	d.min <- 0.2
	D.max <- 3
	for (i in 1:dim(x)[1]) {
		# calculate coeficients
		C.f <- (4*(x.2[i]/x.3[i])-1)/(4*(x.2[i]/x.3[i])-4) + 0.615*x.3[i]/x.2[i]
		K <- (G*x.3[i]^4)/(8*x.1[i]*x.2[i]^3)
		sigma.p <- F.p/K
		l.f <- 	F.max/K + 1.05*(x.1[i]+2)*x.3[i]
		g.1 <- 1 + 0.00001*max(c(8*C.f*F.max*x.2[i]/pi/x.3[i]^3-S,0))
		g.2	<- 1+ max(c(l.f-l.max,0))
		g.3 <- 1 + 10^2*max(c(d.min-x.3[i],0))
		g.4	<- 1 + 10^2*max(c(	x.2[i]-D.max,0))
		g.5 <- 1+ 10^2*max(c(3-x.2[i]/x.3[i],0))
		g.6 <- 1 + max(c(sigma.p-sigma.pm,0))
		g.7 <- 1 + 10^2*max(c(sigma.p+(F.max-F.p)/K+1.05*(x.1[i]+2)*x.3[i]-l.f,0))
		g.8 <- 1 + 10^2*max(c(sigma.w-(F.max-F.p)/K,0))
		Y[i] <- Y[i] * prod(c(g.1,g.2,g.3,g.4,g.5,g.6,g.7,g.8)^3)
	}
	Y[Y<0 | Y==0] <- Inf
	return(-Y)
}

csd <- c(f=csd.f,d=list(csd.d),tf=csd.tf,type=1,opt=-2.658559)


#######################################################################
# Coil Spring Design (uCSD) with soft constraints
# This version uses unordered - categorical - discrete variables
#
# Dim:		: 3
# Domain  : {	0.0090 0.0095 0.0104 0.0118 0.0128 0.0132
#							0.0140 0.0150 0.0162 0.0173 0.0180 0.0200
#							0.0230 0.0250 0.0280 0.0320 0.0350 0.0410
#							0.0470 0.0540 0.0630 0.0720 0.0800 0.0920
#							0.1050 0.1200 0.1350 0.1480 0.1620 0.1770
#							0.1920 0.2070 0.2250 0.2440 0.2630 0.2830
#							0.3070 0.3310 0.3620 0.3940 0.4375 0.5000	} x {1,...,70} x (0.6,3)
# Optimum : f=2.658559 (best known)

ucsd.d <- list(
	list("u",seq(1,70)),		# x1 - number of coils
	list("u",c(	0.0090,0.0095,0.0104,0.0118,0.0128,0.0132,  # x3 - wire diameter
							0.0140,0.0150,0.0162,0.0173,0.0180,0.0200,
							0.0230,0.0250,0.0280,0.0320,0.0350,0.0410,
							0.0470,0.0540,0.0630,0.0720,0.0800,0.0920,
							0.1050,0.1200,0.1350,0.1480,0.1620,0.1770,
							0.1920,0.2070,0.2250,0.2440,0.2630,0.2830,
							0.3070,0.3310,0.3620,0.3940,0.4375,0.5000)),
	list("x",c(0.6,3))) # x2 - spring diameter

ucsd.tf <- function(u,o,x) {
	dim(u) <- c(length(u)/2,2)
	X <- cbind(ucsd.d[[1]][[2]][u[,1]],x,ucsd.d[[2]][[2]][u[,2]])
	return(X)
}

ucsd.f <- function(u,o,x) {
	X <- ucsd.tf(u,o,x)	
	x.1 <- X[,1]
	x.2 <- X[,2]
	x.3 <- X[,3]
	Y <- pi^2*x.2*x.3^2*(x.1+2)/4
	# constraints handling
	G <- 11.5*10^6
	F.p <- 300
	F.max <- 1000
	S <- 189000
	sigma.pm <- 6
	sigma.w <- 1.25
	l.max <- 14
	d.min <- 0.2
	D.max <- 3
	for (i in 1:dim(x)[1]) {
		# calculate coeficients
		C.f <- (4*(x.2[i]/x.3[i])-1)/(4*(x.2[i]/x.3[i])-4) + 0.615*x.3[i]/x.2[i]
		K <- (G*x.3[i]^4)/(8*x.1[i]*x.2[i]^3)
		sigma.p <- F.p/K
		l.f <- 	F.max/K + 1.05*(x.1[i]+2)*x.3[i]
		g.1 <- 1 + 0.00001*max(c(8*C.f*F.max*x.2[i]/pi/x.3[i]^3-S,0))
		g.2	<- 1+ max(c(l.f-l.max,0))
		g.3 <- 1 + 10^2*max(c(d.min-x.3[i],0))
		g.4	<- 1 + 10^2*max(c(	x.2[i]-D.max,0))
		g.5 <- 1+ 10^2*max(c(3-x.2[i]/x.3[i],0))
		g.6 <- 1 + max(c(sigma.p-sigma.pm,0))
		g.7 <- 1 + 10^2*max(c(sigma.p+(F.max-F.p)/K+1.05*(x.1[i]+2)*x.3[i]-l.f,0))
		g.8 <- 1 + 10^2*max(c(sigma.w-(F.max-F.p)/K,0))
		Y[i] <- Y[i] * prod(c(g.1,g.2,g.3,g.4,g.5,g.6,g.7,g.8)^3)
	}
	Y[Y<0 | Y==0] <- Inf
	return(-Y)
}

ucsd <- c(f=ucsd.f,d=list(ucsd.d),tf=ucsd.tf,type=1,opt=-2.658559)


#######################################################################
# Pressure Vessal Design - case C (PVD.C)
# This version uses ordered discrete variables
#
# Dim:		: 4
# Domain  : [1.000 - 12.500 by 0.0625
#            0.625 - 12.500 by 0.0625 or (!) 0.6 - 12.500 by 0.0625
#            0.0 - 240.0 (continuous)
#            0.0 - 240.0 (continuous) ]
# Optimum : 7006.35774 (best known)

pvd.c.d <- list(
	list("o",c(seq(1,12.5,0.0625))),
	list("o",c(seq(0.625,12.5,0.0625))),	 
	list("x",c(0,240)),
	list("x",c(0,240)))

pvd.c.tf <- function(u,o,x) {
	dim(x) <- c(length(x)/2,2)
	dim(o) <- c(length(o)/2,2)
	o <- round(o)
	o[o<1] <- 1
	o[,1][o[,1]>length(pvd.c.d[[1]][[2]])] <- length(pvd.c.d[[1]][[2]])
	o[,2][o[,2]>length(pvd.c.d[[2]][[2]])] <- length(pvd.c.d[[2]][[2]])
	X <- cbind(pvd.c.d[[1]][[2]][o[,1]],pvd.c.d[[2]][[2]][o[,2]],x)
	return(X)
}

pvd.c.f <- function(u,o,x) {
	X <- pvd.c.tf(u,o,x)
	x.1 <- X[,1]
	x.2 <- X[,2]
	x.3 <- X[,3]
	x.4 <- X[,4]
	Y <- 0.6224*x.1*x.3*x.4 + 1.7781*x.2*x.3^2 + 3.1611*x.1^2*x.4 + 19.84*x.1^2*x.3	
	# constraints handling
	for (i in 1:dim(x)[1]) {
		# calculate coeficients
		if	 (
			# g1
			-0.0193*x.3[i] + x.1[i] < 0 |
			# g2
			-0.00954*x.3[i] + x.2[i] < 0 |
			# g3
			-750*1728.0 + pi*x.3[i]^2*x.4[i] + 4/3*pi*x.3[i]^3 < 0 |
			# g4
			-x.4[i] + 240 < 0 |
			#g5
			x.1[i] < 1 | x.1[i] > 12.5	|
			# g6
			x.2[i] < 0.625 | x.2[i] > 12.5 |
			# g7
			x.3[i] < 0.0 | x.3[i] > 240 |
			# g8
			x.4[i] < 0.0 | x.4[i] > 240 )	
		Y[i] <- Inf
	}
	return(-Y)
}

pvd.c <- c(f=pvd.c.f,d=list(pvd.c.d),tf=pvd.c.tf,type=1,opt=-7006.35774)


#######################################################################
# Pressure Vessal Design - case B (PVD.B)
# This version uses ordered discrete variables
#
# Dim:		: 4
# Domain  : [1.125 - 12.500 by 0.0625
#            0.625 - 12.500 by 0.0625
#            0.0 - 240.0 (continuous)
#            0.0 - 240.0 (continuous) ]
# Optimum : 7197.72893 (best known)

pvd.b.d <- list(
	list("o",c(seq(1.125,12.5,0.0625))),
	list("o",c(seq(0.625,12.5,0.0625))),
	list("x",c(0,240)),
	list("x",c(0,240)))

pvd.b.tf <- function(u,o,x) {
	dim(x) <- c(length(x)/2,2)
	dim(o) <- c(length(o)/2,2)
	o <- round(o)
	o[o<1] <- 1
	o[,1][o[,1]>length(pvd.b.d[[1]][[2]])] <- length(pvd.b.d[[1]][[2]])
	o[,2][o[,2]>length(pvd.b.d[[2]][[2]])] <- length(pvd.b.d[[2]][[2]])
	X <- cbind(pvd.b.d[[1]][[2]][o[,1]],pvd.b.d[[2]][[2]][o[,2]],x)
	return(X)
}

pvd.b.f <- function(u,o,x) {
	X <- pvd.b.tf(u,o,x)
	x.1 <- X[,1]
	x.2 <- X[,2]
	x.3 <- X[,3]
	x.4 <- X[,4]
	Y <- 0.6224*x.1*x.3*x.4 + 1.7781*x.2*x.3^2 + 3.1611*x.1^2*x.4 + 19.84*x.1^2*x.3
	# constraints handling
	for (i in 1:dim(x)[1]) {
		# calculate coeficients
		if	 (
			# g1
			-0.0193*x.3[i] + x.1[i] < 0 |
			# g2
			-0.00954*x.3[i] + x.2[i] < 0 |
			# g3
			-750*1728.0 + pi*x.3[i]^2*x.4[i] + 4/3*pi*x.3[i]^3 < 0 |
			# g4
			-x.4[i] + 240 < 0 |
			#g5
			x.1[i] < 1.125 | x.1[i] > 12.5	|
			# g6
			x.2[i] < 0.625 | x.2[i] > 12.5 |
			# g7
			x.3[i] < 0.0 | x.3[i] > 240 |
			# g8
			x.4[i] < 0.0 | x.4[i] > 240 )
		Y[i] <- Inf
	}
	return(-Y)
}

pvd.b <- c(f=pvd.b.f,d=list(pvd.b.d),tf=pvd.b.tf,type=1,opt=-7197.72893)


#######################################################################
# Pressure Vessal Design - case A (PVD.A)
# This version uses ordered discrete variables
#
# Dim:		: 4
# Domain  : [1.100 - 12.500 by 0.0625
#            0.6 - 12.500 by 0.0625
#            0.0 - 240.0 (continuous)
#            0.0 - 240.0 (continuous) ]
# Optimum : 7019.03110 (best known) 

pvd.a.d <- list(
	list("o",c(seq(1.1,12.5,0.0625))),
	list("o",c(seq(0.6,12.5,0.0625))),
	list("x",c(0,240)),
	list("x",c(0,240)))

pvd.a.tf <- function(u,o,x) {
	dim(x) <- c(length(x)/2,2)
	dim(o) <- c(length(o)/2,2)
	o <- round(o)
	o[o<1] <- 1
	o[,1][o[,1]>length(pvd.a.d[[1]][[2]])] <- length(pvd.a.d[[1]][[2]])
	o[,2][o[,2]>length(pvd.a.d[[2]][[2]])] <- length(pvd.a.d[[2]][[2]])
	X <- cbind(pvd.a.d[[1]][[2]][o[,1]],pvd.a.d[[2]][[2]][o[,2]],x)
	return(X)
}

pvd.a.f <- function(u,o,x) {
	X <- pvd.a.tf(u,o,x)
	x.1 <- X[,1]
	x.2 <- X[,2]
	x.3 <- X[,3]
	x.4 <- X[,4]
	Y <- 0.6224*x.1*x.3*x.4 + 1.7781*x.2*x.3^2 + 3.1611*x.1^2*x.4 + 19.84*x.1^2*x.3
	# constraints handling
	for (i in 1:dim(x)[1]) {
		# calculate coeficients
		if	 (
			# g1
			-0.0193*x.3[i] + x.1[i] < 0 |
			# g2
			-0.00954*x.3[i] + x.2[i] < 0 |
			# g3
			-750*1728.0 + pi*x.3[i]^2*x.4[i] + 4/3*pi*x.3[i]^3 < 0 |
			# g4
			-x.4[i] + 240 < 0 |
			#g5
			x.1[i] < 1.1 | x.1[i] > 12.5	|
			# g6
			x.2[i] < 0.6 | x.2[i] > 12.5 |
			# g7
			x.3[i] < 0.0 | x.3[i] > 240 |
			# g8
			x.4[i] < 0.0 | x.4[i] > 240 )
		Y[i] <- Inf
	}
	return(-Y)
}

pvd.a <- c(f=pvd.a.f,d=list(pvd.a.d),tf=pvd.a.tf,type=1,opt=-7019.03110)


#######################################################################
# Pressure Vessal Design - case A (uPVD.A) - unordered
# This version uses unordered - categorical - discrete variables
#
# Dim:		: 4
# Domain  : [1.100 - 12.500 by 0.0625
#            0.6 - 12.500 by 0.0625
#            0.0 - 240.0 (continuous)
#            0.0 - 240.0 (continuous) ]
# Optimum : 7019.03110 (best known)

upvd.a.d <- list(
	list("u",c(seq(1.1,12.5,0.0625))),
	list("u",c(seq(0.6,12.5,0.0625))),
	list("x",c(0,240)),
	list("x",c(0,240)))

upvd.a.tf <- function(u,o,x) {
	dim(x) <- c(length(x)/2,2)
	dim(u) <- c(length(u)/2,2)
	X <- cbind(upvd.a.d[[1]][[2]][u[,1]],upvd.a.d[[2]][[2]][u[,2]],x)
	return(X)
}

upvd.a.f <- function(u,o,x) {
	X <- upvd.a.tf(u,o,x)
	x.1 <- X[,1]
	x.2 <- X[,2]
	x.3 <- X[,3]
	x.4 <- X[,4]
	Y <- 0.6224*x.1*x.3*x.4 + 1.7781*x.2*x.3^2 + 3.1611*x.1^2*x.4 + 19.84*x.1^2*x.3
	# constraints handling
	for (i in 1:dim(x)[1]) {
		# calculate coeficients
		if	 (
			# g1
			-0.0193*x.3[i] + x.1[i] < 0 |
			# g2
			-0.00954*x.3[i] + x.2[i] < 0 |
			# g3
			-750*1728.0 + pi*x.3[i]^2*x.4[i] + 4/3*pi*x.3[i]^3 < 0 |
			# g4
			-x.4[i] + 240 < 0 |
			#g5
			x.1[i] < 1.1 | x.1[i] > 12.5	|
			# g6
			x.2[i] < 0.6 | x.2[i] > 12.5 |
			# g7
			x.3[i] < 0.0 | x.3[i] > 240 |
			# g8
			x.4[i] < 0.0 | x.4[i] > 240 )
		Y[i] <- Inf
	}
	return(-Y)
}

upvd.a <- c(f=upvd.a.f,d=list(upvd.a.d),tf=upvd.a.tf,type=1,opt=-7019.03110)

 
#######################################################################
# Pressure Vessal Design - case B (uPVD.B) - unordered
# This version uses unordered - categorical - discrete variables
#
# Dim:		: 4
# Domain  : [1.125 - 12.500 by 0.0625
#            0.625 - 12.500 by 0.0625
#            0.0 - 240.0 (continuous)
#            0.0 - 240.0 (continuous) ]
# Optimum : 7197.72893 (best known)

upvd.b.d <- list(
	list("u",c(seq(1.125,12.5,0.0625))),
	list("u",c(seq(0.625,12.5,0.0625))),
	list("x",c(0,240)),
	list("x",c(0,240)))

upvd.b.tf <- function(u,o,x) {
	dim(x) <- c(length(x)/2,2)
	dim(u) <- c(length(u)/2,2)
	X <- cbind(upvd.b.d[[1]][[2]][u[,1]],upvd.b.d[[2]][[2]][u[,2]],x)
	return(X)
}

upvd.b.f <- function(u,o,x) {
	X <- upvd.b.tf(u,o,x)
	x.1 <- X[,1]
	x.2 <- X[,2]
	x.3 <- X[,3]
	x.4 <- X[,4]
	Y <- 0.6224*x.1*x.3*x.4 + 1.7781*x.2*x.3^2 + 3.1611*x.1^2*x.4 + 19.84*x.1^2*x.3
	# constraints handling
	for (i in 1:dim(x)[1]) {
		# calculate coeficients
		if	 (
			# g1
			-0.0193*x.3[i] + x.1[i] < 0 |
			# g2
			-0.00954*x.3[i] + x.2[i] < 0 |
			# g3
			-750*1728.0 + pi*x.3[i]^2*x.4[i] + 4/3*pi*x.3[i]^3 < 0 |
			# g4
			-x.4[i] + 240 < 0 |
			#g5
			x.1[i] < 1.125 | x.1[i] > 12.5	|
			# g6
			x.2[i] < 0.625 | x.2[i] > 12.5 |
			# g7
			x.3[i] < 0.0 | x.3[i] > 240 |
			# g8
			x.4[i] < 0.0 | x.4[i] > 240 )
		Y[i] <- Inf
	}
	return(-Y)
}

upvd.b <- c(f=upvd.b.f,d=list(upvd.b.d),tf=upvd.b.tf,type=1,opt=-7197.72893)


#######################################################################
# Pressure Vessal Design - case C (uPVD.C) - unordered
# This version uses unordered - categorical - discrete variables
#
# Dim:		: 4
# Domain  : [1.000 - 12.500 by 0.0625
#            0.625 - 12.500 by 0.0625 or (!) 0.6 - 12.500 by 0.0625
#            0.0 - 240.0 (continuous)
#            0.0 - 240.0 (continuous) ]
# Optimum : 7006.35774 (best known)

upvd.c.d <- list(
	list("u",c(seq(1,12.5,0.0625))),
	list("u",c(seq(0.625,12.5,0.0625))),	 
	list("x",c(0,240)),
	list("x",c(0,240)))

upvd.c.tf <- function(u,o,x) {
	dim(x) <- c(length(x)/2,2)
	dim(u) <- c(length(u)/2,2)
	X <- cbind(upvd.c.d[[1]][[2]][u[,1]],upvd.c.d[[2]][[2]][u[,2]],x)
	return(X)
}

upvd.c.f <- function(u,o,x) {
	X <- upvd.c.tf(u,o,x)
	x.1 <- X[,1]
	x.2 <- X[,2]
	x.3 <- X[,3]
	x.4 <- X[,4]
	Y <- 0.6224*x.1*x.3*x.4 + 1.7781*x.2*x.3^2 + 3.1611*x.1^2*x.4 + 19.84*x.1^2*x.3
	# constraints handling
	for (i in 1:dim(x)[1]) {
		# calculate coeficients
		if	 (
			# g1
			-0.0193*x.3[i] + x.1[i] < 0 |
			# g2
			-0.00954*x.3[i] + x.2[i] < 0 |
			# g3
			-750*1728.0 + pi*x.3[i]^2*x.4[i] + 4/3*pi*x.3[i]^3 < 0 |
			# g4
			-x.4[i] + 240 < 0 |
			#g5
			x.1[i] < 1 | x.1[i] > 12.5	|
			# g6
			x.2[i] < 0.625 | x.2[i] > 12.5 |
			# g7
			x.3[i] < 0.0 | x.3[i] > 240 |
			# g8
			x.4[i] < 0.0 | x.4[i] > 240 )
	
		Y[i] <- Inf
	}
	return(-Y)
}

upvd.c <- c(f=upvd.c.f,d=list(upvd.c.d),tf=upvd.c.tf,type=1,opt=-7006.35774)


#######################################################################
# Thermal Insulation System Design (TISD)
#
# Dim:		: 3(n+1) - n=number of intercepts
# Domain  : See below
# Optimum : Depending on problem formulation
# Comment : This is a quite complicated problem to define. We implement two 
#           versions, one using ordered and one categorical variables. 
#           However, we define the material data only once, also the problem 
#           requires several global variables to be defined beforehand. These
#           variables define the size and other aspects of the problem:
#						max.intercepts - maximum number of intercpets that may be used
#           T.hot - the hot temperature (outside of the insulated system)
#           T.cold - the cold temperature (inside of the insulated system)

# tabulated data from Matlab
# ALUMINUM
# TEMPERATURE IN R 
# t = [0 7.2 40 80 100 140 180 200 240 280 300 340 380 400 440 480 500 540];
# THERMAL CONDUCTIVITY IN Btu/hr-ft-F
# k = [0 20 105 158 159 136 121 119 117 116 116 116 116 116 116 116 116 116];
#
# CARBON STEEL
# TEMPERATURE IN R 
# t = [0 7.2 40 80 100 140 180 200 240 280 300 340 380 400 440 480 500 540];
# THERMAL CONDUCTIVITY IN Btu/hr-ft-F
# k = [0 1.7 15 25.1 29.5 34.4 36.4 37 37.6 37.6 37.6 37.6 37.6 37.6 37.6 
#      37.6 37.6 37.6];
#  
# EPOXY NORMAL
# TEMPERATURE IN K
# t = [0 20 77 195 297];
# THERMAL CONDUCTIVITY IN W/m-K
# k = [0 0.15 0.2 0.3 0.35]; 
#
# EPOXY PLANE
# TEMPERATURE IN K
# t = [0 20 77 195 297];
# THERMAL CONDUCTIVITY IN W/m-K
# k = [0 0.2 0.26 0.44 0.5];
#
# NYLON
# TEMPERATURE IN R 
# t = [0 7.2 40 80 100 140 180 200 240 280 300 340 380 400 440 480 500 540];
# THERMAL CONDUCTIVITY IN Btu/hr-ft-F
# k = [0 0.0072 0.064 0.125 0.148 0.170 0.185 0.188 0.194 0.2 0.202 0.202 
#      0.202 0.202 0.202 0.202 0.202 0.202];
#
# STEEL
# TEMPERATURE IN R 
# t = [0 7.2 40 80 100 140 180 200 240 280 300 340 380 400 440 480 500 540];
# THERMAL CONDUCTIVITY IN Btu/hr-ft-F
# k = [0 0.14 1.26 3 3.7 4.68 5.49 5.72 5.24 6.53 7 7.22 7.64 7.75 8.02 8.26 
#      8.43 8.67];
#
# TEFLON
# TEMPERATURE IN R 
# t = [0 7.2 40 80 100 140 180 200 240 280 300 340 380 400 440 480 500 540];
# THERMAL CONDUCTIVITY IN Btu/hr-ft-F
# k = [0 0.0266 0.0855 0.117 0.125 0.135 0.142 0.142 0.143 0.146 0.148 0.15 
#      0.15 0.15 0.15 0.15 0.15 0.15];
#
#
# CONVERSION CALCULATIONS (IF NECESSARY)
# CONVERT TEMPERATURE TO K
# t = t/1.8;
# CONVERT THERMAL CONDUCTIVITY TO W/m-K
# k = k/0.57782;
# CONVERT THERMAL CONDUCTIVITY TO W/cm-K
# k = k/100;

# tabulated data in R form

# ALUMINUM
# TEMPERATURE IN K 
alu.t <- c(0,7.2,40,80,100,140,180,200,240,280,300,340,380,400,440,480,500,540) 
         / 1.8
# THERMAL CONDUCTIVITY IN W/m-K
alu.k <- c(0,20,105,158,159,136,121,119,117,116,116,116,116,116,116,116,116,116) 
         / 0.57782

# CARBON STEEL
# TEMPERATURE IN K 
cbst.t <- c(0,7.2,40,80,100,140,180,200,240,280,300,340,380,400,440,480,500,540) 
          / 1.8
# THERMAL CONDUCTIVITY IN W/m-K
cbst.k <- c(0,1.7,15,25.1,29.5,34.4,36.4,37,37.6,37.6,37.6,37.6,37.6,37.6,37.6,
          37.6,37.6,37.6)	/ 0.57782

# EPOXY NORMAL
# TEMPERATURE IN K
epxn.t <- c(0,20,77,195,297)
# THERMAL CONDUCTIVITY IN W/m-K
epxn.k <- c(0,0.15,0.2,0.3,0.35)

# EPOXY PLANE
# TEMPERATURE IN K
epxp.t <- c(0,20,77,195,297)
# THERMAL CONDUCTIVITY IN W/m-K
epxp.k <- c(0,0.2,0.26,0.44,0.5)

# NYLON
# TEMPERATURE IN K 
nyl.t <- c(0,7.2,40,80,100,140,180,200,240,280,300,340,380,400,440,480,500,540) 
         / 1.8
# THERMAL CONDUCTIVITY IN W/m-K
nyl.k <- c(0,0.0072,0.064,0.125,0.148,0.170,0.185,0.188,0.194,0.2,0.202,0.202,
         0.202,0.202,0.202,0.202,0.202,0.202) / 0.57782

# STEEL
# TEMPERATURE IN K 
steel.t <- c(0,7.2,40,80,100,140,180,200,240,280,300,340,380,400,440,480,500,540) 
           / 1.8
# THERMAL CONDUCTIVITY IN W/m-K
steel.k <- c(0,0.14,1.26,3,3.7,4.68,5.49,5.72,5.24,6.53,7,7.22,7.64,7.75,8.02,
           8.26,8.43,8.67) / 0.57782

# TEFLON
# TEMPERATURE IN K 
tef.t <- c(0,7.2,40,80,100,140,180,200,240,280,300,340,380,400,440,480,500,540) 
         / 1.8
# THERMAL CONDUCTIVITY IN W/m-K
tef.k <- c(0,0.0266,0.0855,0.117,0.125,0.135,0.142,0.142,0.143,0.146,0.148,0.15,
         0.15,0.15,0.15,0.15,0.15,0.15) / 0.57782

# Comment:
# Ants choose wx[i]
# Then it gets normalized (to be saved in the archive): 
#			wx[i] <- n*wx[i]/sum(wx)
# The actual values are calculated (to be used in objective function calculation):
#			dx[i] <- wx[i]*L/n
# The same is done for temperatures (i.e., we use delta T rather than T).

#######################################################################

# TISD - ordered version

tisd.method <- "fmm"

tisd.mat <- list(
		splinefun(nyl.t,nyl.k,method=tisd.method), # nylon (1)
		splinefun(steel.t,steel.k,method=tisd.method), # steel (2)
		splinefun(alu.t,alu.k,method=tisd.method), # aluminium (3)
		splinefun(cbst.t,cbst.k,method=tisd.method), # carbon steel (4)
		splinefun(epxn.t,epxn.k,method=tisd.method), # epoxy normal (5)
		splinefun(epxp.t,epxp.k,method=tisd.method), # epoxy plaine (6)
		splinefun(tef.t,tef.k,method=tisd.method)) # teflon (7)

# evaluation of thermal conductivity for a given material at a given point
tisd.evl <- function(x,m) {
	return(tisd.mat[[m]](x))
}

# unordered and ordered sets MUST be defined first
# max.intercepts - the maximal number of intercepts allowed
# T.cold - the cold temperature
# T.hot - the hot temperature
tisd.d <- c(
	# material type - 8 - intercept is removed
	rep(list(list("o",seq(1,length(tisd.mat)))),max.intercepts+1), 
	# delta temperature - dT (as a fraction of available range)
	rep(list(list("x",c(0,1))),max.intercepts+1), 
	# delta width - dx (L gets normalized)
	rep(list(list("x",c(0,1))),max.intercepts+1)) 

tisd.tf <- function(u,o,x) {
	X <- list()
	dim(o) <- c(length(o)/(max.intercepts+1),max.intercepts+1)
	dim(x) <- c(length(o)/(max.intercepts+1),(max.intercepts+1)*2)
	o <- round(o)
	o[o<1] <- 0
	o[o>length(tisd.d[[1]][[2]])] <- length(tisd.d[[1]][[2]])
	for (i in 1:dim(x)[1]) {
		idx <- o[i,]>0 # choose only those which are not used
		dT <- x[i,1:(max.intercepts+1)] # separate the dT values
		dT <- dT[idx] # remove the unused ones
		dT <- dT / sum(dT) # normalize dT
		dT <- T.cold + cumsum(dT * (T.hot - T.cold)) # translate dT into absolute values
		dx <- x[i,(max.intercepts+2):(2*(max.intercepts+1))] # separate the dx values
		dx <- dx[idx] # remove the unused ones
		dx <- dx / sum(dx) # normalize dx
		# note that indexing number of temperaturs is different from dx!
		X <- c(X, list(list(sum(idx),tisd.d[[1]][[2]][o[i,idx]],dx,c(T.cold,dT)))) 
	}
	return(X)																																																		
}

tisd.ls <- function(u,o,x) {
	O <- o
	o <- round(o)
	o[o<1] <- 1
	o[o>length(tisd.d[[1]][[2]])] <- length(tisd.d[[1]][[2]])
	idx <- o==8
	dT <- x[,1:(max.intercepts+1)]
	dT[idx] <- 0
	dim(dT) <- c(length(dT)/(max.intercepts+1),max.intercepts+1)
	sums.dT <- apply(dT,1,sum)
	dT <- dT / sums.dT
	dx <- x[,(max.intercepts+2):(2*(max.intercepts+1))]
	dx[idx] <- 0
	dim(dx) <- c(length(dx)/(max.intercepts+1),max.intercepts+1)
	sums.dx <- apply(dx,1,sum)
	dx <- dx / sums.dx
	X <- cbind(dT,dx)
	return(list(u,O,X,tisd.f(u,O,X),dim(X)[1]))
}

tisd.f <- function(u,o,x) {
	X <- tisd.tf(u,o,x)
	P <- rep(0,length(X))
	for (i in 1:length(X)) {
		if (min(x[i,])<0) {
			P[i] <- Inf
		}
		else {
			for (j in 0:(X[[i]][[1]]-1)) {
				if (X[[i]][[4]][j+1]>=71) C <- 2.5
					else if (X[[i]][[4]][j+1]<=4.2) C <- 5
						else C <- 4
				T.i <- X[[i]][[4]][j+1]
				T.i.plus.1 <- X[[i]][[4]][j+2]
				dx.i <-	 X[[i]][[3]][j+1]
				m.i <- X[[i]][[2]][j+1]
				if (j>0) {
					T.i.minus.1 <- X[[i]][[4]][j]
					dx.i.minus.1 <- X[[i]][[3]][j]
					m.i.minus.1 <- X[[i]][[2]][j]
				}
				if (j>0)
					P[i] <- P[i] + C*(T.hot/T.i-1)*
						(integrate(tisd.evl,T.i,T.i.plus.1,m=m.i)$value/dx.i-
						integrate(tisd.evl,T.i.minus.1,T.i,m=m.i.minus.1)$value/dx.i.minus.1)
				else
					P[i] <- P[i] + C*(T.hot/T.i-1)*
						integrate(tisd.evl,T.i,T.i.plus.1,m=m.i)$value/dx.i
			}
		}	    
	}
	return(-P/100)
}

tisd <- c(f=tisd.f,d=list(tisd.d),tf=tisd.tf,type=1,opt=0)

# input simulator based on literature data
tisd.in <- function(I,T,dx,T.cold,T.hot) {
	o <- I
	dim(o) <- c(1,length(I))
	x <- c(diff(c(T.cold,T,T.hot))/(T.hot-T.cold),dx)
	dim(x) <- c(1,2*length(I))
	assign("T.cold",T.cold,.GlobalEnv)
	assign("T.hot",T.hot,.GlobalEnv)
	assign("max.intercepts",length(I)-1,.GlobalEnv)
	return(tisd.ls(NULL,o,x))
}

tisd.verify <- function(materials, temperatures, positions) {
	o <- array(materials,dim=c(1,length(materials)))
	temp <- (temperatures - T.cold)/(T.hot-T.cold)
	temp <- c(temp[1],diff(temp))
	temp <- c(temp,1-sum(temp))
	x <- array(c(temp, positions),dim=c(1,length(temp)+length(positions)))
	return(tisd.f(NULL,o,x))
}

#######################################################################

# TISD - unordered - categorical - version

utisd.method <- tisd.method

utisd.mat <- tisd.mat

# evaluation of thermal conductivity for a given material at a given point
utisd.evl <- function(x,m) {
	return(utisd.mat[[m]](x))
}

# unordered and ordered sets MUST be defined first
# max.intercepts - the maximal number of intercepts allowed
# T.cold - the cold temperature
# T.hot - the hot temperature
utisd.d <- c(
	# material type - 8 - intercept is removed
	rep(list(list("u",seq(1,length(utisd.mat)))),max.intercepts+1), 
	# delta temperature - dT (as a fraction of available range)
	rep(list(list("x",c(0,1))),max.intercepts+1),
	# delta width - dx (L gets normalized)
	rep(list(list("x",c(0,1))),max.intercepts+1)) 

utisd.tf <- function(u,o,x) {
	X <- list()
	dim(u) <- c(length(u)/(max.intercepts+1),max.intercepts+1)
	dim(x) <- c(length(u)/(max.intercepts+1),(max.intercepts+1)*2)
	for (i in 1:dim(x)[1]) {
		idx <- u[i,]>0 # choose only those which are not used
		dT <- x[i,1:(max.intercepts+1)] # separate the dT values
		dT <- dT[idx] # remove the unused ones
		dT <- dT / sum(dT) # normalize dT
		dT <- T.cold + cumsum(dT * (T.hot - T.cold)) # translate dT into absolute values
		dx <- x[i,(max.intercepts+2):(2*(max.intercepts+1))] # separate the dx values
		dx <- dx[idx] # remove the unused ones
		dx <- dx / sum(dx) # normalize dx
		# note that indexing number of temperaturs is different from dx!
		X <- c(X, list(list(sum(idx),utisd.d[[1]][[2]][u[i,idx]],dx,c(T.cold,dT)))) 
	}
	return(X)																																																		
}

utisd.ls <- function(u,o,x) {
	idx <- u==8
	dT <- x[,1:(max.intercepts+1)]
	dT[idx] <- 0
	dim(dT) <- c(length(dT)/(max.intercepts+1),max.intercepts+1)
	sums.dT <- apply(dT,1,sum)
	dT <- dT / sums.dT
	dx <- x[,(max.intercepts+2):(2*(max.intercepts+1))]
	dx[idx] <- 0
	dim(dx) <- c(length(dx)/(max.intercepts+1),max.intercepts+1)
	sums.dx <- apply(dx,1,sum)
	dx <- dx / sums.dx
	X <- cbind(dT,dx)
	return(list(u,o,X,utisd.f(u,o,X),dim(X)[1]))
}

utisd.f <- function(u,o,x) {
	X <- utisd.tf(u,o,x)
	P <- rep(0,length(X))
	for (i in 1:length(X)) {
		if (min(x[i,])<0) {
			P[i] <- Inf
		}
		else {
			for (j in 0:(X[[i]][[1]]-1)) {
				if (X[[i]][[4]][j+1]>=71) C <- 2.5
					else if (X[[i]][[4]][j+1]<=4.2) C <- 5
						else C <- 4
				T.i <- X[[i]][[4]][j+1]
				T.i.plus.1 <- X[[i]][[4]][j+2]
				dx.i <-	 X[[i]][[3]][j+1]
				m.i <- X[[i]][[2]][j+1]
				if (j>0) {
					T.i.minus.1 <- X[[i]][[4]][j]
					dx.i.minus.1 <- X[[i]][[3]][j]
					m.i.minus.1 <- X[[i]][[2]][j]
				}
				if (j>0)
					P[i] <- P[i] + C*(T.hot/T.i-1)*
						(integrate(utisd.evl,T.i,T.i.plus.1,m=m.i)$value/dx.i-
						integrate(utisd.evl,T.i.minus.1,T.i,m=m.i.minus.1)$value/dx.i.minus.1)
				else
					P[i] <- P[i] + C*(T.hot/T.i-1)*
						integrate(utisd.evl,T.i,T.i.plus.1,m=m.i)$value/dx.i
			}
		}	    
	}
	return(-P/100)
}

utisd <- c(f=utisd.f,d=list(utisd.d),tf=utisd.tf,type=1,opt=-25.36)
